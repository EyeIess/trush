

<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from www.net-snmp.org/wiki/index.php/Agent_Architecture by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 May 2024 18:00:15 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>Agent Architecture - Net-SNMP Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"Agent_Architecture","wgTitle":"Agent Architecture","wgCurRevisionId":5906,"wgRevisionId":5906,"wgArticleId":2199,"wgIsArticle":!0,"wgIsRedirect":!1,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Architecture","Agent"],"wgBreakFrames":!1,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Agent_Architecture","wgRelevantArticleId":2199,"wgIsProbablyEditable":!1,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits"]);
} );</script>
<link rel="stylesheet" href="../load34a1.css?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.content.externallinks%7Cmediawiki.skinning.interface%7Cskins.monobook.styles&amp;only=styles&amp;skin=monobook" />
<!--[if IE 6]><link rel="stylesheet" href="/wiki/skins/MonoBook/IE60Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 7]><link rel="stylesheet" href="/wiki/skins/MonoBook/IE70Fixes.css?303" media="screen" /><![endif]-->
<meta name="ResourceLoaderDynamicStyles" content="" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}</style>
<script async="" src="../load3a95.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=monobook"></script>
<meta name="generator" content="MediaWiki 1.26.3" />
<link rel="shortcut icon" href="../../favicon.html" />
<link rel="search" type="application/opensearchdescription+xml" href="../opensearch_desc.php" title="Net-SNMP Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="../api251f.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Net-SNMP Wiki Atom feed" href="../apidf90.php?title=Special:RecentChanges&amp;feed=atom" />
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Agent_Architecture skin-monobook action-view">
<div id="globalWrapper">
		<div id="column-content">
			<div id="content" class="mw-body" role="main">
				<a id="top"></a>
				
				<div class="mw-indicators">
</div>
				<h1 id="firstHeading" class="firstHeading" lang="en">Agent Architecture</h1>
				
				<div id="bodyContent" class="mw-body-content">
					<div id="siteSub">From Net-SNMP Wiki</div>
					<div id="contentSub"></div>
										<div id="jump-to-nav" class="mw-jump">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>

					<!-- start content -->
					<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>During typical usage of the Simple Network Management Protocol (SNMP), the software that handles SNMP requests on a network node is called an agent.  The Net-SNMP agent (<a href="Snmpd.html" title="Snmpd">snmpd</a>) is responsible for handling incoming requests passed to it from the Net-SNMP library's <a href="Transport.html?title=Transport&amp;action=edit&amp;redlink=1" class="new" title="Transport (page does not exist)">transport</a> and processing layers.  This page describes how the agent works internally.  If you're interested in implementing a MIB written in C-code for the Net-SNMP agent, this page is a good place to start.  A good next step after reading this page is the <a href="TUT_Writing_a_MIB_Module.html" title="TUT:Writing a MIB Module">TUT:Writing a MIB Module</a> page.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Agent_Code_Structure"><span class="tocnumber">1</span> <span class="toctext">Agent Code Structure</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Startup"><span class="tocnumber">2</span> <span class="toctext">Startup</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#MIB_Module_Registration"><span class="tocnumber">2.1</span> <span class="toctext">MIB Module Registration</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Registry_API"><span class="tocnumber">2.2</span> <span class="toctext">Registry API</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#The_Where:_netsnmp_handler_registration"><span class="tocnumber">2.2.1</span> <span class="toctext">The <i>Where</i>: netsnmp_handler_registration</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#The_What:_A_Handler_Definition"><span class="tocnumber">2.2.2</span> <span class="toctext">The <i>What</i>: A Handler Definition</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Registering_the_Resulting_Handler"><span class="tocnumber">2.2.3</span> <span class="toctext">Registering the Resulting Handler</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#Handler_Chains"><span class="tocnumber">3</span> <span class="toctext">Handler Chains</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Agent_Startup_and_Registration"><span class="tocnumber">3.1</span> <span class="toctext">Agent Startup and Registration</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Handler_Types"><span class="tocnumber">3.2</span> <span class="toctext">Handler Types</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Request_Processing"><span class="tocnumber">4</span> <span class="toctext">Request Processing</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Calling_the_Handler"><span class="tocnumber">4.1</span> <span class="toctext">Calling the Handler</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Calling_sub-handlers"><span class="tocnumber">4.2</span> <span class="toctext">Calling sub-handlers</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Injectable_Run-Time_Handlers"><span class="tocnumber">4.3</span> <span class="toctext">Injectable Run-Time Handlers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-15"><a href="#Passing_Information_Between_Handlers"><span class="tocnumber">5</span> <span class="toctext">Passing Information Between Handlers</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="#Adding_Information"><span class="tocnumber">5.1</span> <span class="toctext">Adding Information</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Retrieving_the_Data_Later"><span class="tocnumber">5.2</span> <span class="toctext">Retrieving the Data Later</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Agent_Data"><span class="tocnumber">5.3</span> <span class="toctext">Agent Data</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Multi-tasking"><span class="tocnumber">6</span> <span class="toctext">Multi-tasking</span></a></li>
<li class="toclevel-1 tocsection-20"><a href="#Shutting_Down"><span class="tocnumber">7</span> <span class="toctext">Shutting Down</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Agent_Code_Structure">Agent Code Structure</span></h2>
<p>The agent is made up of many pieces.  These pieces include parts from multiple libraries and different parts of the agent itself.  It usually interacts with libraries, the network, plugins, other processes, the file system, the local OS, and the local OS's kernel.
</p><p>It's code is contained in the <i>agent/</i> sub-directory of the main source tree, and the <i>main()</i> function can be found in <i>agent/snmpd.c</i>.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="File_Agent-architecture.html" class="image"><img alt="Agent-architecture.png" src="../images/thumb/1/1f/Agent-architecture.png/300px-Agent-architecture.png" width="300" height="225" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Agent-architecture.html" class="internal" title="Enlarge"></a></div></div></div></div>
<h2><span class="mw-headline" id="Startup">Startup</span></h2>
<p>Upon starting, the agent goes through the following steps (in <i>SnmpDaemonMain()</i>):
</p>
<ol><li> reads command line options</li>
<li> decides whether it's a master or subagent</li>
<li> calls init_agent()
<ul><li> initializes the mib-module registration tree</li>
<li> registers its own configuration file tokens and callbacks</li>
<li> initializes the <i><a href="Agent_Helpers.html" title="Agent Helpers">Agent Helpers</a></i></li></ul></li>
<li> initializes all the compiled-in mib modules</li>
<li> initializes the base libnetsnmp library</li>
<li> opens all the required ports to listen on</li>
<li> forks</li>
<li> saves persistent data (it's likely at least something has changed already)</li>
<li> sends a <a href="ColdStart.html?title=ColdStart&amp;action=edit&amp;redlink=1" class="new" title="ColdStart (page does not exist)">coldStart</a> trap</li>
<li> invokes <i>receive()</i> to perform the main packet handling</li></ol>
<h3><span class="mw-headline" id="MIB_Module_Registration">MIB Module Registration</span></h3>
<p>MIB modules, which are responsible for implementing portions of the <a href="MIB.html" title="MIB">MIB</a> tree, have the opportunity to register <i>callbacks</i> for any portion of the MIB tree when they are initialized.  Registrations can functionally come from any of the following sources:
</p>
<ol><li> directly compiled in code</li>
<li> dynamically loaded shared objects</li>
<li> subagents (through one of the <a href="AgentX.html?title=AgentX&amp;action=edit&amp;redlink=1" class="new" title="AgentX (page does not exist)">AgentX</a> or <a href="SMUX.html?title=SMUX&amp;action=edit&amp;redlink=1" class="new" title="SMUX (page does not exist)">SMUX</a> protocols)</li>
<li> configuration files
<ul><li> <a href="Proxy.html?title=Proxy&amp;action=edit&amp;redlink=1" class="new" title="Proxy (page does not exist)">Proxies</a></li>
<li> <a href="Perl.html?title=Perl&amp;action=edit&amp;redlink=1" class="new" title="Perl (page does not exist)">Embedded Perl</a> code</li></ul></li></ol>
<h3><span class="mw-headline" id="Registry_API">Registry API</span></h3>
<p>MIB Modules register themselves by defining two things
</p>
<ol><li> a <i>netsnmp_handler_registration</i> structure containing "where" in the OID tree to register the MIB</li>
<li> a <i>netsnmp_mib_handler</i> structure indicating "what" code is registering to handle the requests</li></ol>
<p>The name "handler" is exactly what it sounds like: it is a mechanism that "handles a request".  The term is used frequently throughout the API.
</p>
<h4><span class="mw-headline" id="The_Where:_netsnmp_handler_registration">The <i>Where</i>: netsnmp_handler_registration</span></h4>
<p>The netsnmp_handler_registration structure looks like following:
</p>
<pre> typedef struct netsnmp_handler_registration_s {
 
         /** for mrTable listings, and other uses */
         <font color="red">char           *handlerName;</font>
         /** NULL = default context */
         <font color="red">char           *contextName;  </font>  
 
         /**
          * where are we registered at? 
          */
         <font color="red">oid            *rootoid;</font>
         size_t          rootoid_len;
 
         /**
          * handler details 
          */
         <font color="red">netsnmp_mib_handler *handler;</font>
         int             modes;
 
         /**
          * more optional stuff 
          */
         int             priority;
         int             range_subid;
         oid             range_ubound;
         int             timeout;
         int             global_cacheid;
 
         /**
          * void ptr for registeree
          */
         void *          my_reg_void;
 
 } netsnmp_handler_registration;
</pre>
<p>The most important parts of this structure are:
</p>
<ol><li> the "handlerName" of the location in the OID tree.
<ul><li> it should be a unique case-sensitive name.</li>
<li> the reasons for needing it will be understood later, but it's best to name it after the MIB objects it will be referencing, for example "mySuperMibTable".</li></ul></li>
<li> the OID that the handler is registering to handle</li>
<li> a handler definition that indicates <i>what</i> code will actually handle something registered at this point in the OID tree.</li></ol>
<h4><span class="mw-headline" id="The_What:_A_Handler_Definition">The <i>What</i>: A Handler Definition</span></h4>
<p>Now that we know <i>where</i> something needs to be registered, we need to indicate <i>what</i> will actually handle the request.  Information about the handler is stored in a struct, netsnmp_mib_handler, which indicates the <i>handler</i>.  It can store extra handler information and holds the handler access_method.  The access_method is  a pointer to the procedure that will actually fulfill and processes the SNMP requests for the registered OID location.  For simple MIB handling, the access_method procedure is what the MIB coder will have to fill-in or write in order to handle the MIB requests.  This is often done on a access_method per MIB table basis.  The struct netsnmp_mib_handler definition follows:
</p>
<pre> typedef struct netsnmp_mib_handler_s {
         <font color="red">char           *handler_name;</font>
         /** for handler's internal use */
         void           *myvoid; 
         /** for agent_handler's internal use */
         int             flags;
 
         /** if you add more members, you probably also want to update */
         /** _clone_handler in agent_handler.c. */
         
         <font color="red">int             (*access_method) (struct netsnmp_mib_handler_s *,
                                           struct netsnmp_handler_registration_s *,
                                           struct netsnmp_agent_request_info_s *,
                                           struct netsnmp_request_info_s *);</font>
         /** data clone hook for myvoid
          *  deep copy the myvoid member - default is to copy the pointer
          *  This method is only called if myvoid&#160;!= NULL
          *  myvoid is the current myvoid pointer.
          *  returns NULL on failure
          */
         void *(*data_clone)(void *myvoid);
         
         /** data free hook for myvoid
          *  delete the myvoid member - default is to do nothing
          *  This method is only called if myvoid&#160;!= NULL
          */
         void (*data_free)(void *myvoid); /**&lt; data free hook for myvoid */
 
         struct netsnmp_mib_handler_s *next;
         struct netsnmp_mib_handler_s *prev;
 } netsnmp_mib_handler;
</pre>
<p>This contains some important features that need to be set before registering:
</p>
<ol><li> this too needs a name that should describe what the handler does, e.g. "mySuperCoolTableHandler"</li>
<li> it will contain the access_method function pointer to the code that actually will handle any MIB requests</li></ol>
<h4><span class="mw-headline" id="Registering_the_Resulting_Handler">Registering the Resulting Handler</span></h4>
<p>Once populated with the proper data, it needs to be registered with the agent.  This can be done, at the most basic level, through the following API call:
</p>
<pre> netsnmp_register_handler(netsnmp_handler_registration *reginfo);
</pre>
<p>The <i>reginfo</i> structure (the <i>where</i>) will contain a pointer to the handler to serve it (the <i>what</i>).
</p>
<h2><span class="mw-headline" id="Handler_Chains">Handler Chains</span></h2>
<p>Actually, most handler implementations aren't "singular".  That is, they break the processing up into several steps and the resulting code is actually chained together in a series of function calls, ending in the lowest-level handler's code.  For example, there are <i>helpers</i> which are handlers that are designed to "sit in the middle" of a request and do some processing before the request gets to the lower level.  This is useful if some of the code is so common that it's silly to implement the same code in a zillion low level handlers.  For example, the most common problems are separating indexes and the column from a table's OID, caching data from slow operations, and sorting data into a standard SNMP order.  So in the end, simple MIB objects (e.g. scalars) will likely have few steps in the handler chain, but complex MIB objects (e.g. tables) may have many handlers in the middle to "help out along the way".
</p><p>Most of these "middle-class" handlers will have their own registration functions that properly take the lower level's registration object and add themselves to the chain, and then call something higher up to complete the registration.  We refer to this process as "injection".  I.e., a registration function typically "injects" its own handler into the chain.
</p><p>netsnmp_register_handler() is actually the most basic of APIs that mostly says "I'll do everything from here, thanks".
</p>
<h3><span class="mw-headline" id="Agent_Startup_and_Registration">Agent Startup and Registration</span></h3>
<p>Because of this, the real flow of events in most MIB module code during start up looks like this:
</p>
<div class="MediaTransformError" style="width: 687px; height: 0px; display:inline-block;">Error creating thumbnail: Unable to save thumbnail to destination</div>
<p>During start up:
</p>
<ol><li> the agent calls each low-level module to initialize itself</li>
<li> each module then calls a registration function, such as <i>register_table_iterator()</i></li>
<li> which then will inject itself into the chain, and then call a higher registration function, such as <i>register_table()</i></li>
<li> eventually this will reach the core agent's netsnmp_register_handler</li></ol>
<h3><span class="mw-headline" id="Handler_Types">Handler Types</span></h3>
<p>Generally handlers fall into a few different categories:
</p>
<ol><li> handle processing the actual data</li>
<li> provide "help" to the data handlers
<ul><li> table helpers</li>
<li> scalar helpers</li>
<li> other helpers</li></ul></li>
<li> debugging assistants
<ul><li> debug</li>
<li> read_only</li></ul></li>
<li> caching and optimization handlers</li>
<li> backwards compatibility helpers
<ul><li> old_api: allows the original 'UCD' and 'CMU' code to continue working</li></ul></li></ol>
<p>For a full list of the helpers supplied by the Net-SNMP agent library, see <a href="Agent_Helpers.html" title="Agent Helpers">Agent Helpers</a>
</p>
<h2><span class="mw-headline" id="Request_Processing">Request Processing</span></h2>
<p>The agent gets handed packets from the main Net-SNMP libraries packet-processing system, which receives and decodes any packets that arrive through the opened <a href="Transports.html?title=Transports&amp;action=edit&amp;redlink=1" class="new" title="Transports (page does not exist)">transports</a>.  Each <a href="PDU.html?title=PDU&amp;action=edit&amp;redlink=1" class="new" title="PDU (page does not exist)">PDU</a> that arrives from the network is broken down into parts based on which registered module indicated it can respond to a particular OID sub-request.  For example, if the incoming PDU was a GET request for two different OIDS, "sysUpTime.0" and "hrSystemUptime.0", it will analyze the PDU and determine that two different MIB modules are available, one that handles the  OID for "sysUpTime.0" and one that handles the OID for "hrSystemUptime.0".  It will then send sub-requests to each of those those modules for the respective OID.
</p><p>So the agent will construct multiple internal <i>netsnmp_request_info</i> structures and pass them each to the appropriate registered MIB handler.  The netsnmp_request_info structure looks like this:
</p>
<pre>   typedef struct netsnmp_request_info_s {
      /**
       * variable bindings
       */
       <font color="red">netsnmp_variable_list *requestvb;</font>

      /**
       * can be used to pass information on a per-request basis from a
       * helper to the later handlers 
       */
       netsnmp_data_list *parent_data;
 
      /*
       * pointer to the agent_request_info for this request
       */
       struct netsnmp_agent_request_info_s *agent_req_info;

      /** don't free, reference to (struct tree)-&gt;end */
       oid            *range_end;
       size_t          range_end_len;

      /*
       * flags
       */
       int             delegated;
       int             processed;
       int             inclusive;

       int             status;
      /** index in original pdu */
       int             index;
 
      /** get-bulk */
       int             repeat;
       int             orig_repeat;
       netsnmp_variable_list *requestvb_start;

      /* internal use */
       <font color="red">struct netsnmp_request_info_s *next;</font>
       struct netsnmp_request_info_s *prev;
       struct netsnmp_subtree_s      *subtree;
   } netsnmp_request_info;
</pre>
<p>The important parts are highlighted in red.  The first important item is the <a href="Varbind.html?title=Varbind&amp;action=edit&amp;redlink=1" class="new" title="Varbind (page does not exist)">varbind</a>, type netsnmp_variable_list, that the request will process.  The second is a link to any other requests that are all being handed to the module's code.  It's very possible that one module may need to respond to multiple requests, and the agent bundles them all together in a linked list (although there are helpers that can split the list up for you if you'd prefer).
</p>
<h3><span class="mw-headline" id="Calling_the_Handler">Calling the Handler</span></h3>
<p>Each handler is called using the following API:
</p>
<pre> int
 my_super_cool_table_handler(
     netsnmp_mib_handler          *handler,    <font color="blue">// handler stack ptr</font>
     netsnmp_handler_registration *reginfo,    <font color="blue">// returned reg ptr</font>
     netsnmp_agent_request_info   *reqinfo,    <font color="blue">// request &amp; PDU info</font>
     netsnmp_request_info         *requests    <font color="blue">// requests to handle</font>
 )
</pre>
<p>The function is passed everything it needs (and more) to handle the requests:
</p>
<ol><li> a pointer to the handler definition itself (allowing function reuse)</li>
<li> a pointer to the registration information that it's being called to act on</li>
<li> a handler to the global agent request information state</li>
<li> a pointer to linked-list of requests that need to be processed</li></ol>
<h3><span class="mw-headline" id="Calling_sub-handlers">Calling sub-handlers</span></h3>
<p>If you're implementing a handle that will sit in the middle (or even if you aren't, this is still good practice), you should process any data that needs processing and then call the lower-level handlers.  This is easiest to do using the netsnmp_call_next_handler function, passing it the exact same set of arguments.
</p>
<pre>       /*
        * call the next handler 
        */
       ret = netsnmp_call_next_handler(handler, reginfo, reqinfo, request);
</pre>
<p>If this returns a failure case (ie, anything other than <i>SNMP_ERR_NOERROR</i>), you should return that to your parent.
</p>
<h3><span class="mw-headline" id="Injectable_Run-Time_Handlers">Injectable Run-Time Handlers</span></h3>
<p>One nice artifact of having everything named is that you can "inject" some handlers at runtime.  Some specific handlers have been created that allow you to dynamically insert them when the agent starts up to do "special things".  For example, this <a href="Snmpd-2.html" title="Snmpd.conf">snmpd.conf</a> configuration file snippet:
</p>
<pre> injectHandler debug mySuperCoolTable
</pre>
<p>will insert the <i>debug</i> handler into the handler chain for the mySuperCoolTable handler.  The <i>debug</i> handler simply prints extra debugging information out into the agent's log files when <a href="Debugging_output.html" title="Debugging output">Debugging output</a> is turned on (turn on the debug token "helper:debug" to see the output).
</p>
<h2><span class="mw-headline" id="Passing_Information_Between_Handlers">Passing Information Between Handlers</span></h2>
<p>Because there can be any number of handler's in a handler chain and
each handler has it's own set of data, Net-SNMP has a mechanism for
passing information from one handler in the chain to another one
either lower or higher in the chain.
</p>
<h3><span class="mw-headline" id="Adding_Information">Adding Information</span></h3>
<p>In order to add new information into a request that can be extracted
later, you create a memory pointer that contains the information and
add it into the request using the <i>netsnmp_request_add_list_data()</i>
function.  This function takes a callback to a function that knows how
to free the data once the request is done processing.
</p>
<pre> struct my_data {
   char *something;
 };

 void free_my_data(void *data) {
   /* cast the void pointer into a structure we know about */
   struct my_data *mydata = (struct my_data *) data;

   /* free the data; SNMP_FREE will check for a NULL (can't be freed) */
   SNMP_FREE(mydata-&gt;something);
 }

 int
 my_handler(netsnmp_mib_handler *handler,
            netsnmp_handler_registration *reginfo,
            netsnmp_agent_request_info *reqinfo,
            netsnmp_request_info *requests) {
    struct my_data *mydata = SNMP_MALLOC_STRUCT(my_data);
    mydata-&gt;something = strdup("remember me");
    
    /* ... */
    
    netsnmp_request_add_list_data(request,
                                  netsnmp_create_data_list
                                  ("my stash name",
                                   (void *) mydata,
                                   free_my_data));

    /* ... */
 };
</pre>
<h3><span class="mw-headline" id="Retrieving_the_Data_Later">Retrieving the Data Later</span></h3>
<p>The data can then be retrieved later.  This data might be accessed by
a lower handler, a higher handler, or the same handler that created
it.  As an example, it could be data used during the multiple phases
of SET processing:
</p>
<pre>   struct my_data *mydata;
   mydata = (struct my_data *) 
         netsnmp_request_get_list_data(reqinfo, "my stash name");
</pre>
<p>Then the cached data is available for use!
</p>
<h3><span class="mw-headline" id="Agent_Data">Agent Data</span></h3>
<p>Besides storing information, per request, you can also store
information for a complete set of requests.  I.e., if you need to store
a single piece of information regardless of whether it's for a single
request or a huge number (think a 1,000 OID GET), you can use the
<i>_agent_</i> version of the APIs instead:
</p>
<pre>  netsnmp_agent_add_list_data(reqinfo, ...);
  netsnmp_agent_get_list_data(reqinfo, ...);
</pre>
<h2><span class="mw-headline" id="Multi-tasking">Multi-tasking</span></h2>
<p>Some requests can be processed in parallel.  Although the Net-SNMP
agent is not thread-safe, it is capable of performing some tasks in
parallel.  In particular, if a MIB module implementation indicates to
the main agent that it's "not yet done; please ask again later", the
agent will continue to receive packets and process them if it is safe
to do so.  Typically, the MIB modules that support this <i>delegated</i>
support are waiting for data to be returned from another network, file
handle or other socket.
</p><p>It is not safe to process every type of request in parallel though.
In particular:
</p>
<ul><li> PDUs safely parallel processed:
<ul><li> GET</li>
<li> GETNEXT</li>
<li> GETBULK</li></ul></li>
<li> PDUs which must be processed serially:
<ul><li> SET</li></ul></li></ul>
<p>For SNMP SETs, the agent finishes all outstanding requests and then acts on the SETs that have arrived before continuing on to any other requests in the queue.
</p>
<h2><span class="mw-headline" id="Shutting_Down">Shutting Down</span></h2>

<!-- 
NewPP limit report
Cached time: 20230912061613
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.060 seconds
Real time usage: 0.077 seconds
Preprocessor visited node count: 91/1000000
Preprocessor generated node count: 108/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key n12694_wikidb:pcache:idhash:2199-0!*!0!!en!5!* and timestamp 20230912061613 and revision id 5906
 -->
</div><div class="printfooter">
Retrieved from "<a dir="ltr" href="../index8119.html?title=Agent_Architecture&amp;oldid=5906">http://www.net-snmp.org/wiki/index.php?title=Agent_Architecture&amp;oldid=5906</a>"</div>
					<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Categories</a>: <ul><li><a href="Category_Architecture.html?title=Category:Architecture&amp;action=edit&amp;redlink=1" class="new" title="Category:Architecture (page does not exist)">Architecture</a></li><li><a href="Category_Agent.html" title="Category:Agent">Agent</a></li></ul></div></div>					<!-- end content -->
										<div class="visualClear"></div>
				</div>
			</div>
		</div>
		<div id="column-one">
			<h2>Navigation menu</h2>
					<div id="p-cactions" class="portlet" role="navigation">
			<h3>Views</h3>

			<div class="pBody">
				<ul>
				<li id="ca-nstab-main" class="selected"><a href="Agent_Architecture.html" title="View the content page [c]" accesskey="c">Page</a></li>
				<li id="ca-talk" class="new"><a href="Talk_Agent_Architecture.html?title=Talk:Agent_Architecture&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				<li id="ca-viewsource"><a href="../index2cbe.html?title=Agent_Architecture&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				<li id="ca-history"><a href="../indexaafb.html?title=Agent_Architecture&amp;action=history" title="Past revisions of this page [h]" accesskey="h">History</a></li>
				</ul>
							</div>
		</div>
				<div class="portlet" id="p-personal" role="navigation">
				<h3>Personal tools</h3>

				<div class="pBody">
					<ul>
													<li id="pt-createaccount"><a href="../index6980.html?title=Special:UserLogin&amp;returnto=Agent+Architecture&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li>
													<li id="pt-login"><a href="../index27f2.html?title=Special:UserLogin&amp;returnto=Agent+Architecture" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
											</ul>
				</div>
			</div>
			<div class="portlet" id="p-logo" role="banner">
				<a href="Main_Page.html" class="mw-wiki-logo" title="Visit the main page"></a>
			</div>
				<div class="generated-sidebar portlet" id="p-project" role="navigation">
		<h3>project</h3>
		<div class='pBody'>
							<ul>
											<li id="n-Web-Site"><a href="../../index.html" rel="nofollow">Web Site</a></li>
											<li id="n-Wiki"><a href="Main_Page.html">Wiki</a></li>
											<li id="n-Download"><a href="../../download.html" rel="nofollow">download</a></li>
											<li id="n-Mailing-Lists"><a href="../../support/mailinglists.html" rel="nofollow">Mailing Lists</a></li>
											<li id="n-Bug-Reports"><a href="../../support/bugreports.html" rel="nofollow">Bug Reports</a></li>
											<li id="n-Patches"><a href="../../support/patches.html" rel="nofollow">Patches</a></li>
									</ul>
					</div>
		</div>
		<div class="generated-sidebar portlet" id="p-documentation" role="navigation">
		<h3>documentation</h3>
		<div class='pBody'>
							<ul>
											<li id="n-Tutorials"><a href="Tutorials.html">Tutorials</a></li>
											<li id="n-FAQ"><a href="FAQ.html">FAQ</a></li>
											<li id="n-Good-Answers"><a href="Category_GoodAnswer.html">Good Answers</a></li>
											<li id="n-Manual-Pages"><a href="../../man/index.html" rel="nofollow">Manual Pages</a></li>
											<li id="n-Tools"><a href="Category_Tools.html">Tools</a></li>
									</ul>
					</div>
		</div>
		<div class="generated-sidebar portlet" id="p-wiki" role="navigation">
		<h3>wiki</h3>
		<div class='pBody'>
							<ul>
											<li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
											<li id="n-randompage"><a href="Notes20111219.html" title="Load a random page [x]" accesskey="x">Random page</a></li>
											<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
									</ul>
					</div>
		</div>
			<div id="p-search" class="portlet" role="search">
			<h3><label for="searchInput">Search</label></h3>

			<div id="searchBody" class="pBody">
				<form action="http://www.net-snmp.org/wiki/index.php" id="searchform">
					<input type='hidden' name="title" value="Special:Search"/>
					<input type="search" name="search" placeholder="Search" title="Search Net-SNMP Wiki [f]" accesskey="f" id="searchInput" />
					<input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchGoButton" class="searchButton" />&#160;
						<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />
				</form>

							</div>
		</div>
			<div class="portlet" id="p-tb" role="navigation">
			<h3>Tools</h3>

			<div class="pBody">
				<ul>
											<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/Agent_Architecture.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
											<li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/Agent_Architecture.html" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
											<li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
											<li id="t-print"><a href="../indexded4.html?title=Agent_Architecture&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
											<li id="t-permalink"><a href="../index8119.html?title=Agent_Architecture&amp;oldid=5906" title="Permanent link to this revision of the page">Permanent link</a></li>
											<li id="t-info"><a href="../index7a6f.html?title=Agent_Architecture&amp;action=info" title="More information about this page">Page information</a></li>
									</ul>
							</div>
		</div>
			</div><!-- end of the left (by default at least) column -->
		<div class="visualClear"></div>
					<div id="footer" role="contentinfo">
						<div id="f-poweredbyico">
									<a href="http://www.mediawiki.org/"><img src="../resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/wiki/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /wiki/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
							</div>
					<ul id="f-list">
									<li id="lastmod"> This page was last modified on 24 November 2015, at 16:03.</li>
									<li id="privacy"><a href="Net-SNMP_Wiki_Privacy_policy.html" title="Net-SNMP Wiki:Privacy policy">Privacy policy</a></li>
									<li id="about"><a href="Net-SNMP_Wiki_About.html" title="Net-SNMP Wiki:About">About Net-SNMP Wiki</a></li>
									<li id="disclaimer"><a href="Net-SNMP_Wiki_General_disclaimer.html" title="Net-SNMP Wiki:General disclaimer">Disclaimers</a></li>
							</ul>
		</div>
		</div>
		<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.loader.state({"user":"ready","user.groups":"ready"});mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","site","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"]);
} );</script><script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({"wgBackendResponseTime":261});
} );</script></body><!-- Cached 20230912061613 -->

<!-- Mirrored from www.net-snmp.org/wiki/index.php/Agent_Architecture by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 14 May 2024 18:00:32 GMT -->
</html>
